(define (accumulate op term init a next b)
  (define (loop i)
    (if (<= i b)
        (op (term i) (loop (next i)) )
        init
  ))
  (loop a)
)
(define (exp2 x)
  (if (= x 0)
      1
      (accumulate * (lambda (x) 2) 1 1 next x )
      )
  )
(define (next a) (+ a 1))
(define (id x) x)

(define (set-add set elem)
  (if (set-contains? set elem)
      set
      (+ set (exp2 elem))
      )
  )
(define (set-remove set elem)
  (if (set-contains? set elem)
      (- set (exp2 elem))
      set
      )
  )
(define (set-empty? set)
  (= set 0)
  )
(define (set-size set)
  (define (helper set result)
    (if (set-empty? set)
        result
        (if (= (remainder set 2) 1)
            (helper (quotient set 2) (next result))
            (helper (quotient set 2) result)
            )
        )
  )
  (helper set 0)
)
(define (count-bits set)
  (define (helper set bits)
    (if (> set 0)
        (helper (quotient set 2) (next bits))
        bits
        )
    )
  (helper set 0)
  )
(define (set-contains? set elem)
  (define (helper s e)
    (if (= e 0)
        (= (remainder s 2) 1)
        (helper (quotient s 2) (- e 1))
        )
    )
  (helper set elem)
  )
(define (revert-bits set)
  (define (helper n result i)
    (if (= n 0)
        result
        (if (= (remainder n 2) 1)
            (helper (quotient n 2) (+ result (exp2 (- i 1))) (- i 1))
            (helper (quotient n 2) result (- i 1))
            )
        )
    )
  (helper set 0 (count-bits set))
  )
(define (min* x y)
  (if (> x y)
      y
      x)
  )
(define (max* x y)
  (if (> x y)
      x
      y)
  )
(define (set-intersect s1 s2)
  (define (helper s1 s2 result i)
    (if (= (min* (count-bits s1) (count-bits s2)) i)
        result
        (if (and (set-contains? s1 i) (set-contains? s2 i))
            (helper s1 s2 (set-add result i) (next i))
            (helper s1 s2 result (next i))
        )
        )
    )
  (helper s1 s2 0 0)
  )
(define (set-union s1 s2)
  (define (helper s1 s2 result i)
    (if (= (max* (count-bits s1) (count-bits s2)) i)
        result
        (if (or (set-contains? s1 i) (set-contains? s2 i))
            (helper s1 s2 (set-add result i) (next i))
            (helper s1 s2 result (next i))
        )
        )
    )
  (helper s1 s2 0 0)
  )
(define (set-difference s1 s2)
  (define (helper s1 s2 result i)
    (if (= (count-bits s1) i)
        result
        (if (and (set-contains? s1 i) (not (set-contains? s2 i)))
            (helper s1 s2 (set-add result i) (next i))
            (helper s1 s2 result (next i))
        )
        )
    )
  (helper s1 s2 0 0)
  )
(define (w n)
  (case n
    ((0) 2)
    ((1) 3)
    ((2) 4)
    ((3) 5)
  )
)
(define (p n)
  (case n
    ((0) 1)
    ((1) 2)
    ((2) 5)
    ((3) 6)
  )
)
(define (set-price set)
  (define (helper i res)
    (if (= i (count-bits set))
        res
        (if (set-contains? set i)
            (helper (next i) (+ res (p i)))
            (helper (next i) res)
            )
        )
    )
  (helper 0 0)
  )

(define (knapsack c n w p)
  (if (or (= n 0) (= c 0))
      0
      (if (> (w (- n 1)) c)
          (knapsack c (- n 1) w p)
          (if (> (+ (p (- n 1)) (set-price (knapsack (- c (w (- n 1))) (- n 1) w p))) (knapsack c (- n 1) w p))
              (set-add (knapsack (- c (w (- n 1))) (- n 1) w p) (- n 1))
              (knapsack c (- n 1) w p)
              )
          )
      )
  )